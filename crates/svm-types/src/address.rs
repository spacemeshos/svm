use crate::impl_bytes_primitive;
use crate::AddressOf;

impl_bytes_primitive!(Address, 20);

macro_rules! impl_addr_type {
    ($id:ident) => {
        #[derive(Debug, Clone, PartialEq, Eq, Hash)]
        pub enum $id {}
    };
}

impl_addr_type!(Author);
impl_addr_type!(Creator);
impl_addr_type!(Template);
impl_addr_type!(App);

/// Address of a Template.
pub type TemplateAddr = AddressOf<Template>;

/// Address of a Template Author.
pub type AuthorAddr = AddressOf<Author>;

/// Address of an App Creator.
pub type CreatorAddr = AddressOf<Creator>;

/// Address of an App.
pub type AppAddr = AddressOf<Author>;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn address_len() {
        assert_eq!(20, Address::len());
    }

    #[test]
    fn address_partial_eq() {
        let addr1 = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr2 = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr3 = Address([
            0x88, 0x77, 0x66, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        assert_eq!(addr1, addr2);
        assert_eq!(addr2, addr1);
        assert_ne!(addr1, addr3);
    }

    #[test]
    fn address_from() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let actual = Address::from(addr.as_slice());

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_from_ptr() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr_ptr: *const u8 = addr.as_ptr();

        let actual = Address::from(addr_ptr);

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_from_c_void() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr_ptr: *const std::ffi::c_void = addr.as_ptr() as _;

        let actual = Address::from(addr_ptr);

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_as_ptr() {
        let addr = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr_ptr: *const u8 = addr.as_ptr();

        assert_eq!(addr, Address::from(addr_ptr));
    }

    #[test]
    fn address_as_slice() {
        let bytes = [
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr = Address(bytes);

        assert_eq!(&bytes[..], addr.as_slice());
    }

    #[test]
    fn address_of_str() {
        let bytes: [u8; 20] = [
            b'a', b'd', b'd', b'r', b'e', b's', b's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];

        let expected = Address::from(&bytes[..]);
        let actual = Address::of("address");

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_fmt_hex() {
        let addr = Address([
            0x10, 0x20, 0x30, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xAA, 0xBB, 0xCC, 0xDD,
        ]);

        assert_eq!("10 20 30 40 ... AA BB CC DD", addr.fmt(4, 4, " "));
    }

    #[test]
    fn address_as_str() {
        let addr = Address([
            0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0,
            0xF0, 0xAB, 0xBC, 0xCD, 0xDE, 0xEF,
        ]);

        assert_eq!(addr.as_str(), "102030405060708090A0B0C0D0E0F0ABBCCDDEEF");
    }
}
