use crate::helpers::{u32_to_le_array, u8_pair_add, u8_triple_add};
use crate::impl_bytes_primitive;
use std::ops::Add;

impl_bytes_primitive!(Address, 20);

/// Assumption: `Address` internal bytes are laid out in *Big-Endian* order.
impl Add<u32> for Address {
    type Output = [u8; 21];

    fn add(self, b: u32) -> Self::Output {
        // `self.0` is an address (Big-Endian order)  `a20 (msb), a19, a18, a17, a16, ..., a1, a0 (lsb)`
        // `b` is a 4-byte number (Big-Endian order): `b3 (msb), b2, b1, b0 (lsb)`
        //
        // output (marked as `c`) will consist of `21 bytes` and not `20 bytes` since a carry might be turned-on
        // `c20 (msb), c19, c18, c17, c16, ..., c3, c2, c1, c0 (lsb)`

        let mut c = [0; 21];
        c[0..20].copy_from_slice(&self.0);

        let a0 = self.0[19];
        let a1 = self.0[18];
        let a2 = self.0[17];
        let a3 = self.0[16];
        let a4 = self.0[15];

        let [b0, b1, b2, b3] = u32_to_le_array(b);

        let (carry0, c0) = u8_pair_add(a0, b0);
        let (carry1, c1) = u8_triple_add(carry0, a1, b1);
        let (carry2, c2) = u8_triple_add(carry1, a2, b2);
        let (carry3, c3) = u8_triple_add(carry2, a3, b3);
        let (carry4, c4) = u8_pair_add(carry3, a4); // we use `u8_pair_add` and not `u8_triple_add` since `b4 = 0`

        c[20] = c0;
        c[19] = c1;
        c[18] = c2;
        c[17] = c3;
        c[16] = c4;
        c[15] = carry4;

        c
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn address_len() {
        assert_eq!(20, Address::len());
    }

    #[test]
    fn address_partial_eq() {
        let addr1 = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr2 = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr3 = Address([
            0x88, 0x77, 0x66, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        assert_eq!(addr1, addr2);
        assert_eq!(addr2, addr1);
        assert_ne!(addr1, addr3);
    }

    #[test]
    fn address_from() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let actual = Address::from(addr.as_slice());

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_from_ptr() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr_ptr: *const u8 = addr.as_ptr();

        let actual = Address::from(addr_ptr);

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_from_c_void() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr_ptr: *const std::ffi::c_void = addr.as_ptr() as _;

        let actual = Address::from(addr_ptr);

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_as_ptr() {
        let addr = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr_ptr: *const u8 = addr.as_ptr();

        assert_eq!(addr, Address::from(addr_ptr));
    }

    #[test]
    fn address_as_slice() {
        let bytes = [
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr = Address(bytes);

        assert_eq!(&bytes[..], addr.as_slice());
    }

    #[test]
    fn address_from_u32() {
        let expected = Address([
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x11, 0x22, 0x33, 0x44,
        ]);

        let actual = Address::from(0x11_22_33_44 as u32);

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_add_u32_no_carry() {
        let expected = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x15, 0x25, 0x35, 0x45,
        ];

        let actual = Address::from(0x11_22_33_44 as u32).add(0x04_03_02_01);

        // `assert_eq!` isn't implemented for an `Array` so we compare slices
        assert_eq!(expected[..], actual[..]);
    }

    #[test]
    fn address_add_u32_carry_0() {
        let expected = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
        ];

        let actual = Address::from(0x00_00_00_FF as u32).add(0x00_00_00_03);

        assert_eq!(expected[..], actual[..]);
    }

    #[test]
    fn address_add_u32_carry_1() {
        let expected = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00,
        ];

        let actual = Address::from(0x00_00_FF_00 as u32).add(0x00_00_03_00);

        assert_eq!(expected[..], actual[..]);
    }

    #[test]
    fn address_add_u32_carry_2() {
        let expected = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,
        ];

        let actual = Address::from(0x00_FF_00_00 as u32).add(0x00_03_00_00);

        assert_eq!(expected[..], actual[..]);
    }

    #[test]
    fn address_add_u32_carry_3() {
        let expected = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00,
        ];

        let actual = Address::from(0xFF_00_00_00 as u32).add(0x03_00_00_00);

        assert_eq!(expected[..], actual[..]);
    }

    #[test]
    fn address_add_u32_carry_4() {
        let expected = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
        ];

        let actual = Address::from(0xFF_FF_00_00_00 as u64).add(0x03_00_00_00);

        assert_eq!(expected[..], actual[..]);
    }

    #[test]
    fn serialize_addr() {
        let origin = Address([
            0x11, 0x22, 0x33, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr_str = serde_json::to_string(&origin).unwrap();
        let deserialized = serde_json::from_str(&addr_str).unwrap();

        assert_eq!(origin, deserialized);
    }
}
