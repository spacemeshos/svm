use crate::impl_bytes_primitive;

impl_bytes_primitive!(Address, 20);

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn address_len() {
        assert_eq!(20, Address::len());
    }

    #[test]
    fn address_partial_eq() {
        let addr1 = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr2 = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr3 = Address([
            0x88, 0x77, 0x66, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        assert_eq!(addr1, addr2);
        assert_eq!(addr2, addr1);
        assert_ne!(addr1, addr3);
    }

    #[test]
    fn address_from() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let actual = Address::from(addr.as_slice());

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_from_ptr() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr_ptr: *const u8 = addr.as_ptr();

        let actual = Address::from(addr_ptr);

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_from_c_void() {
        let expected = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr: Vec<u8> = vec![
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr_ptr: *const std::ffi::c_void = addr.as_ptr() as _;

        let actual = Address::from(addr_ptr);

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_as_ptr() {
        let addr = Address([
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);

        let addr_ptr: *const u8 = addr.as_ptr();

        assert_eq!(addr, Address::from(addr_ptr));
    }

    #[test]
    fn address_as_slice() {
        let bytes = [
            0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let addr = Address(bytes);

        assert_eq!(&bytes[..], addr.as_slice());
    }

    #[test]
    fn address_from_str() {
        let bytes: [u8; 20] = [
            b'a', b'd', b'd', b'r', b'e', b's', b's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];

        let expected = Address::from(&bytes[..]);
        let actual = Address::of("address");

        assert_eq!(expected, actual);
    }

    #[test]
    fn address_fmt_hex() {
        let addr = Address([
            0x10, 0x20, 0x30, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xAA, 0xBB, 0xCC, 0xDD,
        ]);

        assert_eq!("10 20 30 40 ... AA BB CC DD", addr.fmt(4, 4, " "));
    }
}
